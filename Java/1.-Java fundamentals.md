## Basic syntax

## 1. Variables and data types


Primitive Data Types

---

> int – Stores integers (whole numbers) like 100 or -42. (Size: 4 bytes)

> double – Stores decimal numbers like 3.14 or 2.0. (Size: 8 bytes)

> char – Stores single characters like 'A' or 'z'. (Size: 2 bytes)

> boolean – Stores true or false values. (Size: 1 bit)

> byte – Stores small integers from -128 to 127. (Size: 1 byte)

> short – Stores medium-sized integers from -32,768 to 32,767. (Size: 2 bytes)

> long – Stores large integers like 9223372036854775807. (Size: 8 bytes)

> float – Stores decimal numbers but with less precision than double. (Size: 4 bytes)

Non-Primitive Data Types (Reference Types)

---

Represent objects and store references to complex structures.

> String – Stores sequences of characters like "Hello, Java!".

> Arrays – Stores multiple values of the same type (int[] numbers = {1, 2, 3};).

> Classes – Custom data types that define objects.

> Interfaces – Define methods that a class must implement.

---
Notice: lowercase data types are primitives.

    int age = 23; // integer
    double price = 9.89; // double
    boolean isJavaEasy = false; // Boolean
    char grade = 'A'; // character
    String name = "Alejandro" // Text

### Conditionals

    if(age > 16) {
        // code
    } else {
        // code
    }

### For Loop

    for (int i = 0; i < 5; i
    ++) {
        // code
    }

### While Loop

    while (count < 5) {
        // code
        count++;
    }

### Methods

    public static void greet(string name) {
        System.out.println("Hello, " + name)
    }

### Classes and objects

    class Person {
        String name;
        int age;

        pulblic void sayHello(){
            // code
        }
    }

## 2. Data structures

- Arrays

    Fixed-size collection of elements of the same type.

        int[] numbers = {1,2,3,4};

- ArrayList

    Similar to arrays but can grow or shrink dynamically. More flexible than arrays but slower.

        ArrayList<String> list = new ArrayList<>();

- LinkedList

    Stores elements in nodes that are linked that are linked to each other. Efficient insertion/deletion but slower access compared to arrays.

        LinkedList<Integer> numbers = new LinkedList<>();

- HashMap

    Stores data in key-value format for quick lookups. Fast access but does not maintain order.

        HashMap<String, Integer> map = new HashMap<>();
        map.put("Alex", 20);

- HashSet

    Stores unique values without duplicates(ignores them). Faster lookups but does not maintain order.

        HashSet<String> set = new HashSet<>();

- Stack(LIFO)

    Allows push and pop operations. Used for undo operations and recursion.

        Stack<Integer> stack = new stack<>();

- Queue(FIFO)

    Allows elements to be processed in order. Used in scheduling and task management.

        Queue<String> queue = new LinkedList<>();

## 3. Variables and scopes

Types of variables

- Local variables: 
    
    Declared inside a method, constructor or block. Only accessible within where they are defined.

        public void greetings() {
            String hello = "Hello"; // local variable
        }

- Instance variables (Fields): 
    
    Declared inside a class but outside any method or block.

        Class Person {
            String name; // Instance variable
        }

- Static variables (Class variables)

    Declared using the static keyword. Shared among all instances of the class.

        Class MathConstants {
            static double PI = 3.14159;
        }

        System.out.println(MathConstants.PI)

Variable Scope

Scope defines the visibility and lifetime of a variable.

- Method Scope

    Variables inside a method exist only while the method runs.

- Class Scope

    Instance and static variables exist as long as the object or class exists.

- Block Scope

    Variables inside {} blocks exist only within that block.


## Type casting

Is the process of converting one data type into another. There are two main types:

- Implicit casting (Widening)

    Automatically converts a smaller data type to a large one. No loss of data occurs.

        int num = 10;
        double bigNum = num; // implicit conversion from int to double

- Explicit casting (Narrowing)

    Converts a larger data type to a smaller one manually. Data loss may occur due to precision differences.

        double price = 9.99;
        int roundedPrice = (int) price; // Explicit conversion from double to int

- Casting between Non-Primitive Types

    Used with objects and inheritance.
    
    - Upcasting (Subclass -> Superclass): Done automatically. 
    - Downcasting (Superclass -> Subclass): Requires explicit casting.
        
            Class Animal {}
            Class Dog extends Animal {}
            Animal animal = new Dog(); // Upcasting
            Dog dog = (Dog) animal; // Downcasting
